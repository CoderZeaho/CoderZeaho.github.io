var store = [{
        "title": "数组元素和数组名作为函数参数",
        "excerpt":"数组用作函数参数有两种形式： 一种是把数组元素（下标变量）作为实参使用； 一种是把数组名作为函数的形参和实参使用。 1、数组元素（下标变量）作为实参使用 数组元素作为函数实参使用与普通变量是完全相同的，在发生函数调用时，把作为实参的数组元素的值传给形参，只是“拷贝”实参中的变量的值，传送给形参，实现单向的值传送 2、数组名作为函数参数 用数组名作为函数参数与用数组元素作实参有几点不同       用数组元素作函数参数不要求形参也必须是数组，但是用数组名作函数参数时，则要求形参和相对应的实参都是类型相同的数组         在C语言中，数组名除作为变量的标识符之外，数组名还代表了该数组在内存中的起始地址，当数组名作函数参数时，实参与形参之间不是“值传递”，而是“地址传递”，实参数组名将该数组的其实地址传给形参数组，两个数组共享一段内存单元，编译系统不再为形参数组分配存储单元。         在变量做函数参数时，所进行的值传递是单向的。即只能从实参传向形参，不能从形参传回实参。   3、数组名作为函数参数注意事项       形参数组和实参数组类型必须一致，否则出错         在函数形参表中，允许不给出形参数组的长度，或用一个变量来表示数组元素的个数   void xzh(int a[])或写为 void xzh(int a[],int n)n的值由主调函数的实参进行传递 所有的地址都占8个字节   形参数组和实参数组长度可以不相同，因为在调用时，只传递首地址而不检查形参数组的长度。","categories": ["C"],
        "tags": [],
        "url": "http://localhost:4000/c/%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%92%8C%E6%95%B0%E7%BB%84%E5%90%8D%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/"
      },{
        "title": "MAC下配置ZSH",
        "excerpt":"Shell是Linux/Unix的一个外壳。它负责外界与Linux内核的交互，接收用户或其他应用程序的命令，然后把这些命令转化成内核能理解的语言，传给内核，内核是真正干活的，干完之后再把结果返回用户或应用程序。 MAC下面的终端是神器，在实际开发中为开发者带来许多方便，而程序员看到不爽的Shell，就会自己重新写一套，慢慢形成了一些标准，常用的Shell有这么几种，sh、bash、csh等。 在 Linux 里执行这个命令和 MAC 略有不同，你会发现 Mac 多了一个 ZSH，也就是说 OS X 系统预装了个 ZSH，可惜的事ZSH不是很好用，需要配合一些插件和模板：oh-my-zsh 来吧，让我们一起来配置一下吧 1.打开终端，输入命令行，将bash切换为zsh chsh -s /bin/zsh 直接用zsh会很蛋疼，因为zsh功能很强大但是太复杂，所以需要oh-my-zsh来将它简单化。 2.输入命令行，下载oh-my-zsh //1)直接用git从github上面下载包git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh //2) 备份已有的zshrccp ~/.zshrc ~/.zshrc.orig//3)替换zshrccp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc3.重启终端，大功告成，就是这么简单 按照步骤安装完后，可以配置一些常用的命令的“别名”在根目录下输入以下命令 vi .zshrc翻到最下面，输入”i”，vim编辑器插入状态，可以为常用命令起别名，例如：alias gs=’git status’，插入后”ESC”，输入”:wq”(双引号不敲 –”)，退出vim编辑器，重启终端或者输入以下命令立即生效 source .zshrc.local这样就好了，快在ZSH下使用你短命令吧 附：简化git命令 git config --global alias.&lt;handle&gt; &lt;command&gt;比如：git status 改成 git st，这样可以简化命令git config...","categories": ["ZSH"],
        "tags": [],
        "url": "http://localhost:4000/zsh/MAC%E4%B8%8B%E9%85%8D%E7%BD%AEZSH/"
      },{
        "title": "NSDate与时间戳互相转换",
        "excerpt":"NSString日期转换为时间戳： //如格式为:### xxxx-xx-xx xx:xx:xx ### 我们应该怎样把NSString日期转换为时间戳呢NSDateFormatter *formatter = [[NSDateFormatter alloc] init];[formatter setDateFormat:@\"yyyy-MM-dd HH:mm:ss\"];NSDate *date = [formatter dateFromString:dateString];NSTimeInterval interval = [date timeIntervalSince1970];NSString *timeStamp = [NSString stringWithFormat:@\"%i\", (int)interval];如果开发过程中后端返回上述格式的字符串,为NSString写个Category,方便初始化model,如下 @implementation NSString (NSDate)- (NSDate *)dateWithFormat:(NSString *)format;{ NSDateFormatter *formatter = [NSDateFormatter new]; formatter.dateFormat = format; return [formatter dateFromString:self];}@endself.field_name = [[[infoDict formateObjectForKey:@\"field_name\"] dateWithFormat:@\"yyyy-MM-dd HH:mm:ss\"] timeIntervalSince1970]; NSString时间戳转换为NSDate:...","categories": ["Objective-C"],
        "tags": [],
        "url": "http://localhost:4000/objective-c/NSDate%E4%B8%8E%E6%97%B6%E9%97%B4%E6%88%B3%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/"
      },{
        "title": "各种数据类型的空值判断方法",
        "excerpt":"在开发中,请求数据会遇到返回为空的情况,比如得到的情况,我们需要判断是否为空,不为空才封装数据模型,为空则直接返回  id result;//遇到返回&lt;null&gt;的情况 if ([result isEqual:[NSNull null]]) {     return;}  对于对象类型的数据进行空值判断 //可以使用 !(非) 来判断if（!object） return;  对于类似于NSString类型的数据进行空值判断 NSString *string;string == nil;//or [string isEqualToString:@\"\"];  对于类似于NSNumber类型的数据进行空值判断 NSNumber *number;number == nil;//or[number isEqualToNumber:@0];  对于类似于NSArray类型的数据进行空值判断 NSArray *array;array == nil;//or[array count] = 0;  对于类似于NSDictionary类型的数据进行空值判断 NSDictionary *dictionary;[dictionary isEqual:[NSNull null]];//or[dictionary count] = 0;","categories": ["Objective-C"],
        "tags": [],
        "url": "http://localhost:4000/objective-c/%E5%90%84%E7%A7%8D%E7%A9%BA%E5%80%BC%E5%88%A4%E6%96%AD/"
      },{
        "title": "在UIButton上添加UIActivityIndicator及设置大小",
        "excerpt":"开发中会遇到点击一个按钮,按钮上就多一个系统的小菊花,来示操作正在进行,例如下面的加好友按钮 直接上代码 //初始化按钮 UIButton *addFriendButton = [UIButton emptyFrameView]; addFriendButton.layer.masksToBounds = YES; addFriendButton.layer.cornerRadius = 4.f; addFriendButton.layer.borderWidth = 0.5f; addFriendButton.layer.borderColor = [[UIColor green1Color] CGColor]; addFriendButton.titleLabel.font = [UIFont systemFontOfSize:12.1]; [addFriendButton setBackgroundColor:[UIColor white1Color]]; [addFriendButton setTitle:@\"+好友\" forState:UIControlStateNormal]; [addFriendButton addTarget:self action:@selector(didClickAddFriend:) forControlEvents:UIControlEventTouchUpInside];- (IBAction)didClickAddFriend:(id)sender{ //将文字置空 [self.addFriendButton setTitle:nil forState:UIControlStateNormal]; //初始化系统小菊花 UIActivityIndicatorView *addFriendActivityIndicator = [[UIActivityIndicatorView alloc] initWithFrame:self.addFriendButton.bounds]; [addFriendActivityIndicator setUserInteractionEnabled:YES];...","categories": ["Objective-C"],
        "tags": [],
        "url": "http://localhost:4000/objective-c/%E5%9C%A8UIButton%E4%B8%8A%E6%B7%BB%E5%8A%A0UIActivityIndicator%E5%8F%8A%E8%AE%BE%E7%BD%AE%E5%A4%A7%E5%B0%8F/"
      },{
        "title": "Swift 2.0 到 Swift 3.0",
        "excerpt":"问: 报错:The “Swift Language Version” (SWIFT_VERSION) build setting must be set to a supported value for targets which use Swift. This setting can be set in the build settings editor. 解决办法:TARGETS &gt; Build Settings &gt; Swift Language Version,如图设置成3.2及更高版本: 问:当应用程序运行起来,闪过启动页后便成了黑屏 创建工程后,AppDelegate中自动生成应用开始运行时会调用的方法 Swift 2.0 如下: func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?)...","categories": ["Swift"],
        "tags": [],
        "url": "http://localhost:4000/swift/Swift-2.0-%E5%88%B0-Swift-3.0/"
      },{
        "title": "关于必报的几种写法",
        "excerpt":"闭包 闭包是一个特殊的函数,经常用于回调 // 定义闭包类型 : (形参) -&gt; (返回值)// 闭包执行回调类型(值)// 闭包实现回调{ (形参) -&gt; (返回值) in // 执行代码}简单举个例子:在方法中定义闭包实现回调传值 File:WJKHttpTool.swiftimport Foundationclass WJKHttpTool : NSObject { // MARK:定义闭包 func loadData(completion : (_ result : Bool) -&gt; ()) -&gt; () { // MARK:闭包执行回调 completion(true) }}File:WJKViewController.swiftimport UIKitclass ViewController : UIViewController { override func viewDidLoad() { super.viewDidLoad()...","categories": ["Swift"],
        "tags": [],
        "url": "http://localhost:4000/swift/%E5%85%B3%E4%BA%8E%E9%97%AD%E5%8C%85%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95/"
      },{
        "title": "Sublime Text插件安装方法",
        "excerpt":"1.通过 Package Control 进行在线安装 说在前面:Package Control 是一个用来进行在线安装插件的工具，在安装插件前需要先安装 Package Control。 安装 Package Control 安装方法：通过快捷键 Ctrl + `打开 Console，在最底部把下面的代码复制粘贴过去后回车，然后稍微等待一段时间。 import urllib.request,os,hashlib; h = '6f4c264a24d933ce70df5dedcf1dcaee' + 'ebe013ee18cced0ef93d5f746d80ef60'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got...","categories": ["Plugins"],
        "tags": [],
        "url": "http://localhost:4000/plugins/Sublime-Text%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/"
      },]
